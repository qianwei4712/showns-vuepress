import{_ as c,b as o,o as l,c as i,a as s,e as p,w as e,d as n,f as t}from"./app-c367818e.js";const u={},k=t('<div class="catalog"><ul><li><a href="#t0">前言</a></li><li><a href="#t1">使用场景</a></li><li><a href="#t2">LinkedHashMap 参数属性</a><ul><li><a href="#t21">字段属性</a></li><li><a href="#t22">构造方法</a></li></ul></li><li><a href="#t3">功能实现原理</a><ul><li><a href="#t31">从 put 开始测试</a></li><li><a href="#t32">在 HashMap 上创建链表</a></li><li><a href="#t33">缓存移除最旧的元素</a></li><li><a href="#t34">get 访问激活节点</a></li></ul></li><li><a href="#te">参考文章</a></li></ul></div><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> <span id="t0">前言</span></h2><p>阅读 Java 版本为 <strong>1.8.0.25</strong>。</p><p>好久没看集合类的源码了，自从看完 Set 类的源码后，就基本结束了这一块。</p><p>本来计划是开始阅读 <em>ConcurrentHashMap</em> 之前，先把线程安全部分全部学习完。</p><p>不过昨天在别人的博客中看到了 LinkedHashMap 这个类。我发现我居然从来没见过，那就抽一天看下源码。</p><p>LinkedHashMap 源码：<a href="https://gitee.com/qianwei4712/JDK1.8.0.25-read/blob/master/src/main/java/java/util/LinkedHashMap.java" target="_blank">https://gitee.com/qianwei4712/JDK1.8.0.25-read/blob/master/src/main/java/java/util/LinkedHashMap.java</a></p><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/emo/XIKOEQKFKLOO3UE00.jpg" alt=""></p><br><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> <span id="t1">使用场景</span></h2><p>首先，在官方 Java doc 中写到了：</p>',11),d=s("p",null,[s("strong",null,[n("那么啥是 "),s("code",null,"LRU缓存机制"),n(" 呢？？？")])],-1),r=s("p",null,"LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常见的页面置换算法。该算法的思路是，发生缺页中断时，选择未使用时间最长的页面置换出去。 ------- 百度百科",-1),m=s("p",null,[n("那个这样， "),s("code",null,"LRU缓存机制"),n(" 也就很好理解了。")],-1),v=s("p",null,[n("虽然我现在还没开始看代码，"),s("strong",null,"Linked 在 Java 中表示链表"),n(" ，这是众所周知的，盲猜应该是：")],-1),b=t(`<p>好了，到底是不是这样，就从下面开始讲解主要源码。</p><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/emo/TIM图片20200603100834.jpg" alt=""></p><br><h2 id="linkedhashmap-参数属性" tabindex="-1"><a class="header-anchor" href="#linkedhashmap-参数属性" aria-hidden="true">#</a> <span id="t2">LinkedHashMap 参数属性</span></h2><p><code>LinkedHashMap</code> 继承了 <strong>HashMap</strong> ，还实现了 Map 接口（虽然不知道这一步实现有啥意义）。</p><p>关于 HashMap ，呃，讲道理的话，都看 <code>LinkedHashMap</code> 了，不可能没看过 <strong>HashMap</strong> 。</p><p>但还是贴一下以前写的 HashMap 源码解读：<a href="https://blog.csdn.net/m0_46144826/article/details/107749545" target="_blank">侃晕面试官的 HashMap 源码分析 - 这真不是我吹</a></p><p>好嘞，下面正式开始。。。。</p><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/emo/b157f7e95cc44816bcb63e8c72dfc2c4.gif" alt=""></p><br><h3 id="字段属性" tabindex="-1"><a class="header-anchor" href="#字段属性" aria-hidden="true">#</a> <span id="t21">字段属性</span></h3><p><strong>LinkedHashMap</strong> 的底层实现也很简单，基本的功能都是继承自 <strong>HashMap</strong> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * 双向链表的头（最老的节点）。
     */</span>
    <span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> head<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * 双向链表的尾（最新的节点）。
     */</span>
    <span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> tail<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * 此链接的哈希映射的迭代排序方法： true-访问顺序， false-插入顺序
     */</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一看参数基本就知道它的结构了，<strong>链表头尾两个指针引用 ，基本确定这是双向链表</strong> 。</p><p><code>accessOrder</code> 的注释也很明确的说明了，这个链表的访问顺序可以有两种：</p><ul><li><strong>访问顺序表示</strong> ：把访问过的元素放在链表最后，遍历的顺序会随访问而变化</li><li><strong>插入顺序表示</strong> ：直接按照插入的顺序</li></ul><p>其次是链表底层节点，直接继承了 <code>HashMap.Node</code> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>
        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token comment">//节点hash值</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
        <span class="token class-name">V</span> value<span class="token punctuation">;</span>
        <span class="token comment">//下一个节点引用</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此自带 <code>Node</code> 最基础和常用的属性，包括： <strong>hash、key、value</strong> ，再加上继承后新增的 <strong>before、after</strong> 两个前后引用，就可以实现链表节点的基本功能。</p><br><h3 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> <span id="t22">构造方法</span></h3><p>使用 <code>HashMap</code> 时，一般都是直接使用默认无参构造方法。</p><p>但是 <code>LinkedHashMap</code> 具有 <code>访问顺序</code> 和 <code>插入顺序</code> 的模式选择，所以，在构造时推荐带有模式参数的构造方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * <span class="token keyword">@param</span>  <span class="token parameter">initialCapacity</span> 初始容量
     * <span class="token keyword">@param</span>  <span class="token parameter">loadFactor</span>      扩容系数
     * <span class="token keyword">@param</span>  <span class="token parameter">accessOrder</span>     排序模式- true用于访问顺序， false用于插入顺序
     * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IllegalArgumentException</span></span> 如果初始容量或负载系数为负
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>顺便，影响 <code>HashMap</code> 性能的参数就是 <strong>初始长度和扩容系数</strong> ，这两个参数同样对 LinkedHashMap 性能也有影响。</p><blockquote><p>扩容系数又成为负载因子，负载因子越大表示散列表的装填程度越高。</p><p>对于哈希表来说，如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；</p><p>如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。</p><p>当然负载因子的计算离不开哈希表长度，所以这两个参数是影响 hashmap 性能的参数。</p></blockquote><br><h2 id="功能实现原理" tabindex="-1"><a class="header-anchor" href="#功能实现原理" aria-hidden="true">#</a> <span id="t3">功能实现原理</span></h2><p>还是推荐看完 HashMap 源码，对于这些本文基本不会过多：<a href="https://blog.csdn.net/m0_46144826/article/details/107749545" target="_blank">侃晕面试官的 HashMap 源码分析 - 这真不是我吹</a></p><blockquote><p><strong>LinkedHashMap</strong> 没有重写 put 方法，所以添加元素依然是按照 <strong>HashMap</strong> ，哈希桶的方式。</p></blockquote><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/emo/TIM截图20200603095608.png" alt=""></p><p>这不对啊，刚刚不是说好了链表形式嘛？？</p><p><strong>难道是物理上的哈希桶，逻辑上的链表？</strong></p><br><h3 id="从-put-开始测试" tabindex="-1"><a class="header-anchor" href="#从-put-开始测试" aria-hidden="true">#</a> <span id="t31">从 put 开始测试</span></h3><p>先来做个测试，当然是测试访问模式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s <span class="token operator">+</span> <span class="token string">&quot;, &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0, 1, 4, 3, 7, 2, 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>但是在 HashMap 结构下，这个链表结构是如何实现的呢？</strong></p><p>说实话，想到这个问题我真的有点懵，明明 LinkedHashMap 没有重写 put，为什么还有链表相连呢？</p><p>不死心回过头去看 <strong>HashMap</strong> 的 put 方法，居然发现有这么一个玩意儿：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token comment">// 现有键映射，说明该 key已经存在</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//拿到原有值</span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token comment">//回调操作，在 HashMap 中无效</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">//回调操作，在 HashMap 中无效</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/emo/哈哈没想到吧.jpg" alt=""></p><br><h3 id="在-hashmap-上创建链表" tabindex="-1"><a class="header-anchor" href="#在-hashmap-上创建链表" aria-hidden="true">#</a> <span id="t32">在 HashMap 上创建链表</span></h3><p>先看 <code>afterNodeAccess</code> 方法代码，看名称就知道这个方法代表 <strong><code>访问后回调</code></strong> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token comment">// 访问后回调，将节点移到最后面</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>
        <span class="token comment">// 如果遍历顺序是访问顺序（accessOrder = true）</span>
        <span class="token comment">// 并且当前最后一个节点指针并不是该节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获得节点以及前后节点的引用</span>
            <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> 
                <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
            <span class="token comment">//将下一个节点引用设置为null(意思就是打算放在链表最后)</span>
            p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

            <span class="token comment">// 如果原本的上一个节点为空，说明当前节点是第一个节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> head <span class="token operator">=</span> a<span class="token punctuation">;</span>
            <span class="token keyword">else</span>  b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//否则将上一个和下一个进行相连</span>

            <span class="token comment">// 如果原本的下一个节点不为空,将上一个和下一个进行相连</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>
            <span class="token keyword">else</span> last <span class="token operator">=</span> b<span class="token punctuation">;</span>  <span class="token comment">//否则先暂存最后一个节点索引为 before</span>

            <span class="token comment">//最后将该节点连到最后</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> head <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
                last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            tail <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token operator">++</span>modCount<span class="token punctuation">;</span><span class="token comment">//快速失败机制标志位 +1</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在 <code>LinkedHashMap</code> 中添加如下节点：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> datas <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> data <span class="token operator">:</span> datas<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s <span class="token operator">+</span> <span class="token string">&quot;, &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，在 <code>LinkedHashMap</code> 中，它的结构是这样的</p><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/data/java/LinkedHashMap内部结构图.png" alt="LinkedHashMap内部结构图"></p><p>看起来如果有点乱，可以把链表抽取出来</p><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/data/java/LinkedHashMap节点抽取链表.png" alt="LinkedHashMap节点抽取链表"></p><p>可以发现，其实就是一个双向链表。</p><p><strong>所以 LinkedHashMap 其实就是在 HashMap 基础上，再加一个链表。</strong></p><br><h3 id="缓存移除最旧的元素" tabindex="-1"><a class="header-anchor" href="#缓存移除最旧的元素" aria-hidden="true">#</a> <span id="t33">缓存移除最旧的元素</span></h3><p>再看 <code>afterNodeInsertion</code> 方法代码注释如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * 可能删除最旧的节点
     * <span class="token keyword">@param</span> <span class="token parameter">evict</span> 如果为false，则 hashmap 表处于构造阶段
     */</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>
        <span class="token comment">// evict参数不需要管，这是在 HashMap 中就确定的</span>
        <span class="token comment">// 获得第一个节点引用，第一个节点不为null，并且链表断开第一个节点，更改 head 引用</span>
        <span class="token comment">// 最后才移除节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">K</span> key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
            <span class="token comment">// 移除第一个节点</span>
            <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>逻辑也非常简单，其实就是在添加节点后弄一个回调。</p><p>然后主要的断开链接的方法 <code>removeEldestEntry</code> ，原生代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JDK 中，默认返回 false。也就是说默认是不进行删除操作的。</p><p>在该方法的 <code>java doc</code> 上就给出了使用示例，现在我给补全下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMapTest</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_ENTRIES</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token constant">MAX_ENTRIES</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,67),h=t(`<p>同样的，在移除节点是，进行了移除回调 <code>afterNodeRemoval</code> ，步骤和访问类似。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token comment">// 删除节点回调，解除相连</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>
            <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>before <span class="token operator">=</span> p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            tail <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="get-访问激活节点" tabindex="-1"><a class="header-anchor" href="#get-访问激活节点" aria-hidden="true">#</a> <span id="t34">get 访问激活节点</span></h3><p><code>LinkedHashMap</code> 的官方注释上写到了这么一句：</p>`,5),g=t(`<p>所以如果使用了访问模式（accessOrder 为 true），那么在调用 get 时，就会对原有链表进行修改。</p><p>还是调用访问回调，在上文中已经介绍了变化过程。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * 返回指定键所映射到的值；如果此映射不包含键的映射关系，则返回或<span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token keyword">null</span></span></span><span class="token punctuation">}</span>。
     * <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>返回值 null 不一定表示映射不包含该键的映射；
     * 映射也可能显式地将密钥映射到 null。
     * <span class="token punctuation">{</span><span class="token keyword">@link</span> <span class="token reference"><span class="token punctuation">#</span><span class="token field">containsKey</span></span> containsKey<span class="token punctuation">}</span>操作可用于区分这两种情况。
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哦，这里特别的要说明下，因为 <strong>LinkedHashMap 允许 null 作为 key 和 value .</strong></p><p>所以如果 get 返回结果为 <code>null</code> 时，需要特别关注。</p><br><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> <span id="te">参考文章</span></h2><p><a href="https://baike.baidu.com/item/LRU/1269842" target="_blank">https://baike.baidu.com/item/LRU/1269842</a></p><p><a href="https://www.pdai.tech/md/java/collection/java-map-LinkedHashMap&amp;LinkedHashSet.html" target="_blank">https://www.pdai.tech/md/java/collection/java-map-LinkedHashMap&amp;LinkedHashSet.html</a></p><p><a href="http://www.seohuizhou.com/seojiaocheng/12711.html" target="_blank">http://www.seohuizhou.com/seojiaocheng/12711.html</a></p>`,10);function y(f,w){const a=o("font");return l(),i("div",null,[k,s("blockquote",null,[p(a,{color:"red"},{default:e(()=>[n("**这种 map 非常适合建立 LRU 缓存。**")]),_:1})]),d,r,m,v,p(a,{color:"red"},{default:e(()=>[n("**在 LinkedHashMap 环境下，当链表达到某个指定长度，put 方法添加新节点时，移除最长没有访问的元素。具体的实现可以是，顺序添加组建链表，当访问某一个元素节点，将该节点移动至末尾，达到长度需要移除时，移除第一个元素节点。**")]),_:1}),b,p(a,{color:"red"},{default:e(()=>[n("**很简单的实现，设置最大条目，如果当前链表大于最大条目数，就进行删除。当然也可以将最大条目作为构造参数动态设置。**")]),_:1}),h,s("blockquote",null,[p(a,{color:"red"},{default:e(()=>[n("在访问有序的链接散列图中，仅使用get查询地图是一种结构修改。")]),_:1})]),g])}const H=c(u,[["render",y],["__file","LinkedHashMap.html.vue"]]);export{H as default};
