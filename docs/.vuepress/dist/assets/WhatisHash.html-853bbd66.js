import{_ as t,o as e,c as a,f as r}from"./app-c1e62972.js";const s={},l=r('<div class="catalog"><ul><li><a href="#t1">概述</a></li><li><a href="#t2">常见Hash算法</a></li><li><a href="#t3">Hash算法设计因素</a></li><li><a href="#te">参考文章</a></li></ul></div><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> <span id="t1">概述</span></h3><p>Hash 一般称为散列，音译是“哈希”，以下就成之为哈希，毕竟感觉高大上。</p><p>摘自百度百科的哈希的作用：</p><blockquote><p><strong>是把任意长度的输入（又叫做预映射pre-image）通过哈希算法变换成固定长度的输出，该输出就是哈希值。</strong></p></blockquote><p>这种转换是一种压缩映射，也就是，哈希值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。</p><p>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有哈希函数都有下面的特性：</p><ul><li>如果哈希函数计算的输出值不同，那么输入值肯定不同</li><li>如果哈希函数计算的输出值相同，可是输入值不一定相同</li></ul><p><strong>两个不同的输入值，根据同一哈希函数计算出哈希值相同的现象叫做碰撞。</strong></p><p>一般的哈希算法都应该具有下面2个能力：</p><p><strong>抗碰撞能力</strong>：对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。</p><p><strong>抗篡改能力</strong>：对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。</p><br><h3 id="常见hash算法" tabindex="-1"><a class="header-anchor" href="#常见hash算法" aria-hidden="true">#</a> <span id="t2">常见Hash算法</span></h3><table><thead><tr><th style="text-align:center;">算法名</th><th style="text-align:center;">算法简介</th></tr></thead><tbody><tr><td style="text-align:center;">直接定址法</td><td style="text-align:center;">直接以关键字k或者k加上某个常数（k+c）作为哈希地址。</td></tr><tr><td style="text-align:center;">数字分析法</td><td style="text-align:center;">提取关键字中取值比较均匀的数字作为哈希地址。</td></tr><tr><td style="text-align:center;">除留余数法</td><td style="text-align:center;">用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</td></tr><tr><td style="text-align:center;">分段叠加法</td><td style="text-align:center;">按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。<br>然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</td></tr><tr><td style="text-align:center;">平方取中法</td><td style="text-align:center;">如果关键字各个部分分布都不均匀的话，可以先求出它的平方值<br>然后按照需求取中间的几位作为哈希地址。</td></tr><tr><td style="text-align:center;">伪随机数法</td><td style="text-align:center;">采用一个伪随机数当作哈希函数。</td></tr></tbody></table><p>衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。</p><p>任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：</p><table><thead><tr><th style="text-align:center;">方法名</th><th style="text-align:center;">方法介绍</th></tr></thead><tbody><tr><td style="text-align:center;">开放定址法</td><td style="text-align:center;">开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址；<br>只要散列表足够大，空的散列地址总能找到，并将记录存入。</td></tr><tr><td style="text-align:center;">链地址法</td><td style="text-align:center;">将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。<br>即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</td></tr><tr><td style="text-align:center;">再哈希法</td><td style="text-align:center;">当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</td></tr><tr><td style="text-align:center;">建立公共溢出区</td><td style="text-align:center;">将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</td></tr></tbody></table><br><h3 id="hash算法设计因素" tabindex="-1"><a class="header-anchor" href="#hash算法设计因素" aria-hidden="true">#</a> <span id="t3">Hash算法设计因素</span></h3><ol><li>计算散列地址所需要的时间（即hash函数本身不要太复杂）</li><li>关键字的长度</li><li>表长</li><li>关键字分布是否均匀，是否有规律可循</li><li>设计的hash函数在满足以上条件的情况下尽量减少冲突</li></ol><br><p>最后看下 HashMap 的内部结构图，具体分析在以后在 HashMap源码阅读里写。</p><p><img src="https://shiva.oss-cn-hangzhou.aliyuncs.com/picture-master/images/WhatisHash.png" alt="WhatisHash"></p><br><h3 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> <span id="te">参考文章</span></h3><p><a href="https://baike.baidu.com/item/Hash/390310?fr=aladdin" target="_blank">https://baike.baidu.com/item/Hash/390310?fr=aladdin</a></p><p><a href="https://mp.weixin.qq.com/s/qCHkzs4JPOipB-ZzqrfbeQ" target="_blank">https://mp.weixin.qq.com/s/qCHkzs4JPOipB-ZzqrfbeQ</a></p><p><a href="https://blog.csdn.net/u011109881/article/details/80379505" target="_blank">https://blog.csdn.net/u011109881/article/details/80379505</a></p>',30),i=[l];function n(h,d){return e(),a("div",null,i)}const p=t(s,[["render",n],["__file","WhatisHash.html.vue"]]);export{p as default};
