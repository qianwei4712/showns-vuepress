import{_ as n,o as a,c as s,f as t}from"./app-c14a8d33.js";const e={},p=t(`<div class="catalog"><ul><li><a href="#t0">本文概述</a></li><li><a href="#t1">synchronized</a><ul><li><a href="#t11">使用方法</a></li><li><a href="#t12">原理分析</a></li><li><a href="#t13">特性描述</a></li><li><a href="#t14">JDK6 的优化</a></li></ul></li><li><a href="#t2">代码优化</a></li><li><a href="#te">参考文章</a></li></ul></div><h2 id="本文概述" tabindex="-1"><a class="header-anchor" href="#本文概述" aria-hidden="true">#</a> <span id="t0">本文概述</span></h2><p>讲解下 Java 中和并发相关的个关键字：<code>synchronized</code> 。</p><p>因为关键字已经是除了 JVM 外最底层的应用了。。。</p><p>所以除了分析在 JVM 中关键字的作用，其他的只能通过代码举例说明，这样就会显得比较得.......枯燥。</p><p><img src="https://shiva.oss-cn-hangzhou.aliyuncs.com/emo/QQ图片20201111104311.jpg" alt=""></p><br><h2 id="synchronized" tabindex="-1"><a class="header-anchor" href="#synchronized" aria-hidden="true">#</a> <span id="t1">synchronized</span></h2><p>synchronized 关键字是为了解决共享资源竞争的问题，共享资源一般是以对象形式存在的内存片段。</p><p><strong>所以，只有共享资源的读写访问才需要同步化，如果不是共享资源那么根本就没有必要同步。</strong></p><p>对 synchronized 的基础使用其实比较简单：</p><ul><li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li><li>每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁；</li><li>synchronized 修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁。</li></ul><br><h3 id="使用方法" tabindex="-1"><a class="header-anchor" href="#使用方法" aria-hidden="true">#</a> <span id="t11">使用方法</span></h3><p>synchronized 可修饰的对象如下：</p><table><thead><tr><th style="text-align:center;">修饰目标</th><th style="text-align:center;">锁</th></tr></thead><tbody><tr><td style="text-align:center;">实例方法</td><td style="text-align:center;">当前实例对象(即方法调用者)</td></tr><tr><td style="text-align:center;">静态方法</td><td style="text-align:center;">类对象</td></tr><tr><td style="text-align:center;">this</td><td style="text-align:center;">当前实例对象(即方法调用者)</td></tr><tr><td style="text-align:center;">class 对象</td><td style="text-align:center;">类对象</td></tr><tr><td style="text-align:center;">任意 Object 对象</td><td style="text-align:center;">任意示例对象</td></tr></tbody></table><p>简单的使用就不详细讲了。</p><br><h3 id="原理分析" tabindex="-1"><a class="header-anchor" href="#原理分析" aria-hidden="true">#</a> <span id="t12">原理分析</span></h3><p>举个例子，如下 mian 方法代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 jclasslib 查看字节码，main 方法字节码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> 0 new #2 &lt;java/lang/Object&gt;
 3 dup
 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;
 7 dup
 8 astore_1
 9 monitorenter
10 getstatic #3 &lt;java/lang/System.out&gt;
13 iconst_1
14 invokevirtual #4 &lt;java/io/PrintStream.println&gt;
17 aload_1
18 monitorexit
19 goto 27 (+8)
22 astore_2
23 aload_1
24 monitorexit
25 aload_2
26 athrow
27 return
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，有关监视器的几行命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>9 monitorenter
......
18 monitorexit
......
24 monitorexit
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Monitorenter</code> 和 <code>Monitorexit</code> 指令，会让对象在执行，使其锁计数器加1或者减1。</p><p>每一个对象在同一时间只与一个 monitor(锁) 相关联，而一个 monitor 在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的 Monitor 锁的所有权的时候，monitorenter 指令会发生如下3中情况之一：</p><ul><li>monitor 计数器为 0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li><li>如果这个 monitor 已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li><li>这把锁已经被别的线程获取了，等待锁释放</li></ul><p><code>monitorexit指令</code>：释放对于 monitor 的所有权，释放过程很简单，就是讲 monitor 的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该 monitor 的所有权，即释放锁。</p><p>下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：</p><p><img src="https://shiva.oss-cn-hangzhou.aliyuncs.com/data/thread/线程监视器示意图.png" alt="线程监视器示意图"></p><br><h3 id="特性描述" tabindex="-1"><a class="header-anchor" href="#特性描述" aria-hidden="true">#</a> <span id="t13">特性描述</span></h3><ol><li><strong>可重入特性：一个线程可以多次执行 synchronized ，重复获取同一把锁。</strong></li></ol><p>Synchronized 先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。</p><br><ol start="2"><li><strong>不可中断特性：一个锁后，另一个锁想要获得锁，必须处于阻塞或者等待状态。如果第一个线程不释放锁，那么第二个线程会一直阻塞或者等待，不可被中断。</strong></li></ol><br><h3 id="jdk6-的优化" tabindex="-1"><a class="header-anchor" href="#jdk6-的优化" aria-hidden="true">#</a> <span id="t14">JDK6 的优化</span></h3><p>JDK 1.5 之前都只有 监视器 这一个重量级锁。JDK和开发都会大量使用。</p><p>JDK 1.6 的时候进行大量的改进，锁升级的过程为：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p><br><h4 id="cas" tabindex="-1"><a class="header-anchor" href="#cas" aria-hidden="true">#</a> CAS</h4><ul><li>CAS 的全名是：Compare And Swap ，比较再交换。它是现在 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。</li><li>CAS 可以将比较和交换转化为原子操作，这个原子操作直接由 CPU 保证。</li><li>JAVA 中的 CAS 实现例如：AtomicInteger</li></ul><br><p><strong>悲观锁</strong></p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞。</p><p><strong>因此 synchronized 我们也将其称之为 悲观锁，JDK中的ReentrantLock也是一 种悲观锁。</strong> 性能较差!</p><br><p><strong>乐观锁</strong></p><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系,再重试即可。所以不会上锁。</p><p>但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如何没有人修改则更新，如果有人修改则重试。</p><p><strong>CAS这种机制我们也可以将其称之为乐观锁。</strong> 综合性能较好!</p><br><p>CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。 结合 CAS 和 volatile 可以实现无锁并 发，适用于竞争不激烈、多核CPU的场景下。</p><blockquote><ol><li><p>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</p></li><li><p>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。（可以阅读 AtomicInteger 源码获得解释）</p></li></ol></blockquote><br><h4 id="偏向锁" tabindex="-1"><a class="header-anchor" href="#偏向锁" aria-hidden="true">#</a> 偏向锁</h4><p>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</p><p>它的意思是这个锁会偏向于第一个获得它的线程， 会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及ThreadID即可。</p><blockquote><p><strong>偏向锁，仅限在不存在竞争的情况下。</strong></p></blockquote><br><h4 id="轻量级锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁" aria-hidden="true">#</a> 轻量级锁</h4><p>轻量级锁是 JDK1.6 之中加入的新型锁机制。</p><p>它名字中的&quot;轻量级”是相对于使用 monitor 的传统锁而言的，因此传统的锁机制就称为 “重量级” 锁。</p><p>首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。</p><blockquote><p>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。</p></blockquote><br><h4 id="自旋锁" tabindex="-1"><a class="header-anchor" href="#自旋锁" aria-hidden="true">#</a> 自旋锁</h4><p><strong>自旋锁（spinlock）</strong>：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p><p>获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成 busy-waiting。</p><ul><li><strong>使用自旋锁会有以下一个问题：</strong></li></ul><ol><li><p>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</p></li><li><p>上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</p></li></ol><ul><li><strong>自旋锁的优点</strong></li></ul><ol><li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。</li><li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li></ol><br><h4 id="锁消除" tabindex="-1"><a class="header-anchor" href="#锁消除" aria-hidden="true">#</a> 锁消除</h4><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。</p><p>锁消除可以节省毫无意义的请求锁的时间。</p><p>举个例子：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">appendStr</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">appendStr</span><span class="token punctuation">(</span><span class="token class-name">String</span> str1<span class="token punctuation">,</span> <span class="token class-name">String</span> str2<span class="token punctuation">,</span> <span class="token class-name">String</span> str3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>StringBuffer</code> 的 append 方法是一个同步方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">StringBuffer</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    toStringCache <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在 <code>appendStr</code> 方法中，锁头是 <strong>this(new StringBuffer)</strong> ，同时，<span style="color:red;">它是局部变量，不存在竞争</span>。</p></blockquote><p>所以，JVM 会自动消除锁。</p><p>再详细点，这个消除步骤是，即时编译器（JIT）在进行逃逸分析时，进行的优化。</p><br><h4 id="锁粗化" tabindex="-1"><a class="header-anchor" href="#锁粗化" aria-hidden="true">#</a> 锁粗化</h4><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，—直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>简单讲就是：即时编译器将 append 内的锁消除，在 for 循环上加一个锁</strong> 。</p></blockquote><br><h2 id="代码优化" tabindex="-1"><a class="header-anchor" href="#代码优化" aria-hidden="true">#</a> <span id="t2">代码优化</span></h2><table><thead><tr><th>优化注意点</th><th>原因</th></tr></thead><tbody><tr><td>同步代码块内代码尽量少</td><td>执行越快，单位时间内等待时间越短，竞争越少。<br>自旋锁或者轻量级锁就能满足要求，不需要升级。</td></tr><tr><td>将一个锁拆分为多个锁</td><td>例如，HashTable 和 ConcurrenHashMap ，原理和上一条相似。</td></tr><tr><td>读写分离</td><td>读取不加锁，写入和删除加锁</td></tr></tbody></table><br><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> <span id="te">参考文章</span></h2><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html" target="_blank">https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a></p><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html" target="_blank">https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html</a></p><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-final.html" target="_blank">https://www.pdai.tech/md/java/thread/java-thread-x-key-final.html</a></p><p><a href="https://www.bilibili.com/video/BV1QC4y1H7qd?p=11" target="_blank">https://www.bilibili.com/video/BV1QC4y1H7qd?p=11</a></p><p><a href="https://blog.csdn.net/topdeveloperr/article/details/80485900" target="_blank">https://blog.csdn.net/topdeveloperr/article/details/80485900</a></p><p><a href="https://blog.csdn.net/qq_38011415/article/details/89047812" target="_blank">https://blog.csdn.net/qq_38011415/article/details/89047812</a></p><p><a href="https://blog.csdn.net/weixin_42762133/article/details/103241439" target="_blank">https://blog.csdn.net/weixin_42762133/article/details/103241439</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank">https://blog.csdn.net/javazejian/article/details/72828483</a></p><p><a href="https://www.bilibili.com/video/BV1aJ411V763" target="_blank">Java面试热点问题，synchronized原理剖析与优化_哔哩哔哩 (゜-゜)つロ 干杯</a></p><p><a href="https://www.jianshu.com/p/9d3660ad4358?utm_source=oschina-app" target="_blank">https://www.jianshu.com/p/9d3660ad4358?utm_source=oschina-app</a></p>`,107),i=[p];function o(l,c){return a(),s("div",null,i)}const d=n(e,[["render",o],["__file","Synchronized.html.vue"]]);export{d as default};
