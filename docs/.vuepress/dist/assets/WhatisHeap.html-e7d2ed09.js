import{_ as i,o as a,c as e,f as r}from"./app-36b09dbd.js";const t={},p=r('<div class="catalog"><ul><li><a href="#t0">概述</a></li><li><a href="#t1">大顶堆和小顶堆</a></li><li><a href="#t2">堆的构建</a></li><li><a href="#t3">移除结点</a></li><li><a href="#t4">参考文章</a></li></ul></div><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> <span id="t0">概述</span></h3><p>堆是一种 <strong>完全二叉树</strong> ，是一种从上到下，从左到右构建的二叉树。</p><blockquote><p>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p></blockquote><p>在 <strong>Java - PriorityQueue 源码分析</strong> 内，对堆排序进行了讲解，。</p><p>堆是一个典型的，<strong>用物理上线性表示逻辑上非线性的数据结构</strong> ，用数组存储，用二叉树表示逻辑。</p><p>例如下面这个例子的下标排列顺序，数组顺序请注意结点下标：</p><p><img src="https://shiva.oss-cn-hangzhou.aliyuncs.com/picture-master/images/PriorityQueueSource3.png" alt="PriorityQueueSource3"></p><p>堆的下标关系：</p><ol><li>根节点下标为0</li><li>若节点 P 的下标为 i，则左孩子为 2i+1，右孩子为 2i+2</li><li>若节点 P 的下标为 i，则父节点的下标为 (i-1)/2</li></ol><br><h3 id="大顶堆和小顶堆" tabindex="-1"><a class="header-anchor" href="#大顶堆和小顶堆" aria-hidden="true">#</a> <span id="t1">大顶堆和小顶堆</span></h3><p>堆结构分为两种：<strong>大顶堆和小顶堆</strong> 。</p><p>按照字母意思就可以理解。。。</p><p><strong>大顶堆是根结点在整个堆中最大结点，小顶堆则相反。</strong></p><p>在大顶堆中，最大值是根节点，最小值却不一定，这和元素的插入顺序有关系。</p><br><h3 id="堆的构建" tabindex="-1"><a class="header-anchor" href="#堆的构建" aria-hidden="true">#</a> <span id="t2">堆的构建</span></h3><p>以小顶堆为例子，因为在 <strong>PriorityQueue 源码分析</strong> 内已经画过构建顺序图了，就直接拿来用了。</p><p>思想都是一样的，只是在实现中会有语法不同。</p><p><img src="https://shiva.oss-cn-hangzhou.aliyuncs.com/picture-master/images/PriorityQueueSource4.png" alt="PriorityQueueSource4"></p><p>如上图，是在一个小顶堆中，插入一个新元素。PriorityQueue的实现过程中定义了几个中间变量，具体思路为：</p><ol><li><p>在按照完全二叉树的构建规则，从上到下，从左到有插入元素。</p></li><li><p>新插入的元素和父元素比较</p></li><li><p>按照小顶堆规则，若比父元素要小，则和父元素交换。</p></li><li><p>重复上浮步骤直至父元素比它小为止</p></li></ol><br><h3 id="移除结点" tabindex="-1"><a class="header-anchor" href="#移除结点" aria-hidden="true">#</a> <span id="t3">移除结点</span></h3><p>移除结点应该区分为移除根节点和移除根的子树结点。</p><p>但是，实际上两者并没有区别，先看以下图片：</p><p><img src="https://shiva.oss-cn-hangzhou.aliyuncs.com/picture-master/images/PriorityQueueSource5.png" alt="PriorityQueueSource5"></p><p>和添加元素类似，思路为：</p><ol><li><p>先移除指定元素，然后将完全二叉树最后一个元素取出</p></li><li><p>将最后一个元素放置到移除元素的位置</p></li><li><p>如果它的左右子树中存在比它小的元素，或者都比它小，选择左右子树中较小的那个进行互换</p></li><li><p>重复上述步骤直至为叶子结点，或者左右子树都比它大</p></li></ol><br><h3 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> <span id="t4">参考文章</span></h3><p><a href="https://zhuanlan.zhihu.com/p/85518062" target="_blank">https://zhuanlan.zhihu.com/p/85518062</a></p>',33),s=[p];function o(h,l){return a(),e("div",null,s)}const c=i(t,[["render",o],["__file","WhatisHeap.html.vue"]]);export{c as default};
