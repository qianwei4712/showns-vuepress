import{_ as s,b as e,o as t,c as p,e as o,w as c,d as i,f as n}from"./app-28d4f173.js";const l={},r=n(`<div class="catalog"><ul><li><a href="#t0">IOC 概念</a></li><li><a href="#t1">依赖注入和依赖查找</a></li><li><a href="#t2">Spring 的 IoC 容器</a><ul><li><a href="#t21">BeanFactory 容器</a></li><li><a href="#t22">ApplicationContext 容器</a></li></ul></li><li><a href="#te">参考文章</a></li></ul></div><p><img src="https://shiva.oss-cn-hangzhou.aliyuncs.com/picture-master/images/Spring IoC.png" alt="Spring IoC"></p><h3 id="ioc-概念" tabindex="-1"><a class="header-anchor" href="#ioc-概念" aria-hidden="true">#</a> <span id="t0">IOC 概念</span></h3><blockquote><p>Spring Framework 阅读版本为 5.2.x</p></blockquote><p><strong>控制反转 IOC（ Inversion Of Control ）</strong> ：是一种设计思想，它的主要作用是减轻系统的耦合度。实现方式就是，通过一个专门的调控系统，来管理所有对象的生命周期，在某个对象需要依赖其他对象时，由这个调控系统来进行传递。</p><br><p>然后就是经典的、最常见的关于 IOC 的四个问题：</p><ol><li>谁控制谁？</li><li>控制什么？</li><li>为何是反转？</li><li>哪些方面反转了？</li></ol><p>先来用最常见的订单业务举个例子，需要完成的业务是根据订单编号计算订单内的货物总价：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GoodsService</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getById</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//假设获得商品</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是最常见的，根据 货物ID 获得货物实体。然后再看传统的订单业务写法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">GoodsService</span> goodsService<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setGoodsService</span><span class="token punctuation">(</span><span class="token class-name">GoodsService</span> goodsService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>goodsService <span class="token operator">=</span> goodsService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">BigDecimal</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token class-name">String</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//        根据订单ID获得货物列表...</span>
<span class="token comment">//        根据货物ID查询货物，再进行计算</span>
<span class="token comment">//        goodsService.getById(&quot;&quot;);</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们需要完成的业务是，在 Controller 根据 订单ID 计算该订单价格；看看假设代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//假设需要完成一个计算订单价格的业务（假设哦，可能和实际业务不一样，栗子没举好）</span>
    <span class="token comment">//假设这个main 方法是 controller 入口</span>
    <span class="token class-name">OrderService</span> orderService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">GoodsService</span> goodsService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GoodsService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    orderService<span class="token punctuation">.</span><span class="token function">setGoodsService</span><span class="token punctuation">(</span>goodsService<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">BigDecimal</span> orderCount <span class="token operator">=</span> orderService<span class="token punctuation">.</span><span class="token function">calc</span><span class="token punctuation">(</span><span class="token string">&quot;orderId&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这里可以发现，在传统的设计中，我们都是直接通过 new 的方式创建需要依赖的对象，这是程序主动创建对象。</p><p>但是在 Spring 中如何完成？</p><p>将两个业务类都给 Spring IOC 容器管理，goodsService 省略了，一样加上 <code>@Service</code> 注解， <code>@Autowired</code> 注入：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">GoodsService</span> goodsService<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">BigDecimal</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token class-name">String</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//        根据订单ID获得货物列表...</span>
<span class="token comment">//        根据货物ID查询货物，再进行计算</span>
<span class="token comment">//        goodsService.getById(&quot;&quot;);</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//在 Controller中注入 OrderService</span>
<span class="token class-name">BigDecimal</span> orderCount <span class="token operator">=</span> orderService<span class="token punctuation">.</span><span class="token function">calc</span><span class="token punctuation">(</span><span class="token string">&quot;orderId&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个注解相信大家都很熟悉了。那么现在可以思考下上面的四个问题了。。。。</p><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/data/TIM截图20200602231032.png" alt=""></p><p>对比下两种方式，应该很好理解上面的四个问题，我就直接写答案了：</p><ol><li><strong>谁控制谁：</strong> 原本传统的 new 创建对象，是由创建方直接控制期生命周期；有了 IOC 后，变为 IOC 容器来控制所有被依赖对象的生命周期；</li><li><strong>控制什么：</strong> 控制的是被依赖的对象；</li><li><strong>为何是反转：</strong> 传统 new 方式，我们都是自己在对象中主动创建被依赖的对象，这是正转；有了 IOC 后，所依赖的对象由 IOC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转；</li><li><strong>哪些方面反转了：</strong> 所依赖对象的获取被反转了。</li></ol><p>以上就是以 Spring 作为例子的 IOC 实现。</p><br><h3 id="依赖注入和依赖查找" tabindex="-1"><a class="header-anchor" href="#依赖注入和依赖查找" aria-hidden="true">#</a> <span id="t1">依赖注入和依赖查找</span></h3><blockquote><p>这一部分只做下概念介绍</p></blockquote><p>每次问到 Spring 控制反转，都会带上依赖注入 DI，其实依赖注入在上面的例子中已经介绍过实际作用了，它是 IOC 的一种实现方式。</p><p>IOC 有依赖注入（Depedency Injection，DI）和依赖查找（Dependency Lookup，DL）两种实现方式，分别介绍下：</p><p><strong>被放弃的依赖查找</strong> ：实现方式为，容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象，这种方式虽然降低了对象间的依赖，但是同时也使用到了容器的 API。</p><p><strong>Spring 选用的依赖注入</strong> ：由容器负责组件的装配，它会把符合依赖关系的对象通过属性( JavaBean 中的 setter ）或者是构造子传递给需要的对象。</p><p>更详细的有关依赖注入和依赖查找的区别可以参考：<a href="https://www.jianshu.com/p/26654a18d1fe" target="_blank">https://www.jianshu.com/p/26654a18d1fe</a></p><p><span style="color:red;"><strong>所以说，对 Spring 框架来说，控制反转 IoC 是目的（为了解耦），依赖注入 DI 是手段（自动装配）。</strong></span></p><p>到这，应该两个最重要的概念就介绍完了，是不是发现 Spring 的思想也就这么回事？其实 Spring 的核心思想并不复杂，但是这只是开始。。。</p><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/emo/unc/auwnksnda.jpg" alt=""></p><br><h3 id="spring-的-ioc-容器" tabindex="-1"><a class="header-anchor" href="#spring-的-ioc-容器" aria-hidden="true">#</a> <span id="t2">Spring 的 IoC 容器</span></h3><p><strong>IoC 容器是 Spring 框架的核心。</strong> 后面直接称呼为 容器...</p><p>容器创建了所有对象，并管理着他们的整个生命周期，从创建到销毁。然后通过依赖注入来组装。</p><p><strong>我们把这些对象成为 Spring Beans</strong> 。后面就直接用 beans 称呼了.......好嘞，然后继续</p>`,40),d=n('<ul><li>BeanFactory 是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系。</li><li>ApplicationContext 是 BeanFactory 的子接口，也被成为 Spring 上下文。在 BeanFactory 基础上增加了国际化策略、事件机制、资源加载和对 Context 透明创建的支持。</li></ul><br><h4 id="beanfactory-容器" tabindex="-1"><a class="header-anchor" href="#beanfactory-容器" aria-hidden="true">#</a> <span id="t21">BeanFactory 容器</span></h4><p>BeanFactory 是 Spring 容器最基础、最顶级的接口。</p><p>BeanFacoty 有三个直接子类：</p><ul><li><code>ListableBeanFactory</code> ：扩展 BeanFactory 使其支持迭代Ioc容器持有的Bean对象</li><li><code>HierarchicalBeanFactory</code> ：这个工厂接口非常简单，实现了Bean工厂的分层</li><li><code>AutowireCapableBeanFactory</code> ：实现了对存在实例的管理。可以使用这个接口集成其它框架,捆绑并填充并不由 Spring 管理生命周期并已存在的实例</li></ul><p>但是 <code>DefaultListableBeanFactory</code> 才是最终的默认实现，它实现了所有接口。</p><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/data/spring/TIM截图20200603231836.png" alt=""></p><br><h4 id="applicationcontext-容器" tabindex="-1"><a class="header-anchor" href="#applicationcontext-容器" aria-hidden="true">#</a> <span id="t22">ApplicationContext 容器</span></h4><p>这个就是大名鼎鼎的 Spring 容器，它叫做应用上下文，她继承 BeanFactory，所以它是 BeanFactory 的扩展升级版。</p><p>如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的白富美。</p><p>由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有：</p><ol><li>继承 MessageSource，提供国际化的标准访问策略。</li><li>继承 ApplicationEventPublisher ，提供强大的事件机制。</li><li>扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源。</li><li>对 Web 应用的支持</li></ol><p>她的常用实现类如下：</p><ul><li><code>ClassPathXmlApplicationContext</code> ：可以加载类路径下的配置文件，不在的话加载不了</li><li><code>FileSystemXmlApplicationContext</code> ：可以加载磁盘任意路径下的配置文件（必须有访问权限）</li><li><code>AnnotationConfigApplicationContext</code> ： 用于读取注解创建容器的</li></ul><p><img src="http://shiva.oss-cn-hangzhou.aliyuncs.com/data/spring/TIM截图20200603233237.png" alt=""></p><br><h3 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> <span id="te">参考文章</span></h3><p><a target="_blank" href="http://cmsblogs.com/?p=4047&amp;vip=1">http://cmsblogs.com/?p=4047&amp;vip=1</a></p><p><a target="_blank" href="https://www.bilibili.com/video/BV1RE411N7xk">https://www.bilibili.com/video/BV1RE411N7xk</a></p><p><a target="_blank" href="https://www.w3cschool.cn/wkspring/pesy1icl.html">https://www.w3cschool.cn/wkspring/pesy1icl.html</a></p><p><a target="_blank" href="https://www.jianshu.com/p/26654a18d1fe">https://www.jianshu.com/p/26654a18d1fe</a></p><p><a target="_blank" href="https://www.jianshu.com/p/17b66e6390fd">https://www.jianshu.com/p/17b66e6390fd</a></p><p><a target="_blank" href="https://www.jianshu.com/p/fd8e441b98c8">https://www.jianshu.com/p/fd8e441b98c8</a></p><p><a target="_blank" href="https://www.jianshu.com/p/2854d8984dfc">https://www.jianshu.com/p/2854d8984dfc</a></p><p><a target="_blank" href="https://blog.csdn.net/iteye_14104/article/details/82672514">https://blog.csdn.net/iteye_14104/article/details/82672514</a></p>',27);function u(k,v){const a=e("font");return t(),p("div",null,[r,o(a,{color:"red"},{default:c(()=>[i("Spring 提供了两种容器：**Spring BeanFactory 容器** 和 **Spring ApplicationContext 容器** 。")]),_:1}),d])}const g=s(l,[["render",u],["__file","IoCAndDI.html.vue"]]);export{g as default};
