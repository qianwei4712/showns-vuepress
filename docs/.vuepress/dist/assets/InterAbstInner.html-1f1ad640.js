import{_ as t,o as e,c as a,f as n}from"./app-36b09dbd.js";const r={},s=n('<div class="catalog"><ul><li><a href="#t1">接口()</a></li><li><a href="#t2">抽象类()</a></li><li><a href="#t12">接口与抽象类的对比()</a></li><li><a href="#t3">内部类()</a></li></ul></div><h2 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> <span id="t1">接口</span></h2><p>使用 <strong>interface</strong> 关键字创建接口。</p><p>接口用于定义 API。它定义了类必须得遵循的规则。</p><p>接口并不用管具体的实现。接口中的属性默认为Public Static Final.一个类实现这个接口必须实现这个接口中定义的所有的抽象方法。</p><p>Java 8 中，可以在接口声明静态方法和默认普通方法。</p><br><h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> <span id="t2">抽象类</span></h2><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><br><h2 id="接口与抽象类的对比" tabindex="-1"><a class="header-anchor" href="#接口与抽象类的对比" aria-hidden="true">#</a> <span id="t12">接口与抽象类的对比</span></h2><table><thead><tr><th style="text-align:center;">特性</th><th style="text-align:center;">接口</th><th style="text-align:center;">抽象类</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>组合</strong></td><td style="text-align:center;">新类可以组合多个接口</td><td style="text-align:center;">只能继承单一抽象类</td></tr><tr><td style="text-align:center;"><strong>状态</strong></td><td style="text-align:center;">不能包含属性（除了静态属性，不支持对象状态）</td><td style="text-align:center;">可以包含属性，非抽象方法可能引用这些属性</td></tr><tr><td style="text-align:center;"><strong>默认方法 和 抽象方法</strong></td><td style="text-align:center;">不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td><td style="text-align:center;">必须在子类中实现抽象方法</td></tr><tr><td style="text-align:center;"><strong>构造器</strong></td><td style="text-align:center;">没有构造器</td><td style="text-align:center;">可以有构造器</td></tr><tr><td style="text-align:center;"><strong>可见性</strong></td><td style="text-align:center;">隐式 <strong>public</strong></td><td style="text-align:center;">可以是 <strong>protected</strong></td></tr></tbody></table><p>抽象类仍然是一个类，在创建新类时只能继承它一个。而创建类的过程中可以实现多个接口。</p><p><strong>《effective java》第20条</strong>：<strong><span style="color:red;">接口优于抽象类</span></strong></p><blockquote><p>因为 Java 只允许单一继承，所以对抽象类的这种限制严格限制了它们作为类型定义的使用。 任何定义所有必需方法并服从通用约定的类都可以实现一个接口，而不管类在类层次结构中的位置。</p></blockquote><br><h2 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类" aria-hidden="true">#</a> <span id="t3">内部类</span></h2><blockquote><p>一个定义在另一个类中的类，叫作内部类。</p></blockquote><p>内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。</p><p>然而必须要了解，内部类与组合是完全不同的概念，这一点很重要。在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信，而且你用内部类写出的代码更加优雅而清晰，尽管并不总是这样（而且 Java 8 的 Lambda 表达式和方法引用减少了编写内部类的需求）。</p><p>以上摘自 《On Java 8》，中文版翻译 <a href="https://lingcoder.gitee.io/onjava8" target="_blank">https://lingcoder.gitee.io/onjava8</a></p>',23),l=[s];function d(i,o){return e(),a("div",null,l)}const p=t(r,[["render",d],["__file","InterAbstInner.html.vue"]]);export{p as default};
